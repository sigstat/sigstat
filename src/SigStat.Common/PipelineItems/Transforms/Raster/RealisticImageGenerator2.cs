using System.Collections.Generic;
using SigStat.Common.Pipeline;
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.PixelFormats;
using SixLabors.ImageSharp.Processing;
using SixLabors.Primitives;
using System.Linq;
using System;
using System.Numerics;

namespace SigStat.Common.PipelineItems.Transforms.Raster
{
    /// <summary>
    /// Generates a realistic looking image of the Signature based on standard features. Uses blue ink and white paper. It does NOT save the image to file.
    /// <para>Default Pipeline Input: X, Y, T, Pressure, Size, PenDown, Dpi <see cref="Features"/></para>
    /// <para>Default Pipeline Output: OutputImage <see cref="Features.Image"/></para>
    /// </summary>
    public class RealisticImageGenerator2 : PipelineBase, ITransformation
    {
        /// <summary>
        /// Input <see cref="FeatureDescriptor"/> describing the X coordinates of an online signature
        /// </summary>
        [Input]
        public FeatureDescriptor<List<double>> X { get; set; } = Features.X;

        /// <summary>
        /// Input <see cref="FeatureDescriptor"/> describing the Y coordinates of an online signature
        /// </summary>
        [Input]
        public FeatureDescriptor<List<double>> Y { get; set; } = Features.Y;

        /// <summary>
        /// Input <see cref="FeatureDescriptor"/> describing the time values of an online signature
        /// </summary>
        [Input]
        public FeatureDescriptor<List<double>> T { get; set; } = Features.T;

        /// <summary>
        /// Input <see cref="FeatureDescriptor"/> describing the pressure values of an online signature
        /// </summary>
        [Input]
        public FeatureDescriptor<List<double>> Pressure { get; set; } = Features.Pressure;

        /// <summary>
        /// Input <see cref="FeatureDescriptor"/> describing the pressure values of an online signature
        /// </summary>
        [Input]
        public FeatureDescriptor<SizeF> Size { get; set; } = Features.Size;

        /// <summary>
        /// Input <see cref="FeatureDescriptor"/> describing the stroke endings of an online signature
        /// </summary>
        [Input]
        public FeatureDescriptor<List<bool>> PenDown { get; set; } = Features.PenDown;

        /// <summary>
        /// Input <see cref="FeatureDescriptor"/> describing the dots per inch paramater of the device where the  online signature was recorded
        /// </summary>
        public FeatureDescriptor<int> Dpi { get; set; } = Features.Dpi;

        /// <summary>
        /// Output <see cref="FeatureDescriptor"/> describing the generated image of the signature
        /// </summary>
        [Output("RealisticImage")]
        public FeatureDescriptor<Image<Rgba32>> OutputImage { get; set; } = Features.Image;

        // The width of the frame around the generated signature image
        private readonly int frame;

        // Alpha paramater of the Catmull-Rom spline based interpolation
        private readonly double catmullRomAlpha;

        // The DPI of the target device
        private readonly double outputImageDpi;

        // Distance between points generated by the Catmull-Rom spline based interpolation
        // This value determines the number of points between each controll points
        private readonly double catmullRomStep;

        // Base color intensity value for the image generation
        private readonly double baseIntensity;

        // The number of layers a signature is built from.
        private readonly int numberOfLayers;

        // A list describing each layer as a tuple
        private readonly List<(double width, double intensity)> layers;

        // The number of noise layers added to the image
        private readonly int numberOfNoiseLayers;

        // This number determines the scale factor between noise layers.
        // The higher this number, the larger the resolution difference between noise layers.
        private readonly double noiseLayerScale;

        // Upper bound for the random values used when creating noise layers
        private readonly double noiseRandomValueUpperBound;

        public RealisticImageGenerator2(
            int frame,
            double catmullRomAlpha,
            double outputImageDpi,
            double catmullRomStep = 0.01,
            double baseIntensity = 1,
            int numberOfLayers = 5,
            double layerIntensitySlope = 0.33,
            int numberOfNoiseLayers = 5,
            double noiseLayerScale = 5,
            double noiseRandomValueUpperBound = 0.4
        )
        {
            this.frame = frame;
            this.catmullRomAlpha = catmullRomAlpha;
            this.outputImageDpi = outputImageDpi;
            this.catmullRomStep = catmullRomStep;
            this.baseIntensity = baseIntensity;
            this.numberOfLayers = numberOfLayers;
            this.numberOfNoiseLayers = numberOfNoiseLayers;
            this.noiseLayerScale = noiseLayerScale;
            this.noiseRandomValueUpperBound = noiseRandomValueUpperBound;

            // Initializing the layers' values
            layers = new List<(double width, double intensity)>();

            // For the layer width values linear parition the [2, 1] interval
            double layerWidthStep = 1 / (double)(numberOfLayers - 1);
            for (int i = 0; i < numberOfLayers; i++)
            {
                // The width of a layer is decreasing linearly from 2 to 1
                double width = 2 - i * layerWidthStep;

                // The intensity of a layer is increasing linearly and gets throttled at 1.
                // The value of the increase is defined by the layerIntensitySlope parameter.
                // Increasing this value will cause the edge of the signature lines to appear "sharper".
                // It is recommended to keep this value around 1/3 (which is the default value).
                double intensity = ((i + 1) * layerIntensitySlope) > 1 ? 1 : ((i + 1) * layerIntensitySlope);

                // Add the calculated values to the layer
                layers.Add((width, intensity));
            }
        }

        public void Transform(Signature signature)
        {
            List<double> xs = signature.GetFeature(X);
            List<double> ys = signature.GetFeature(Y);
            List<double> ts = signature.GetFeature(T);
            List<double> ps = signature.GetFeature(Pressure);
            List<bool> pendowns = signature.GetFeature(PenDown);
            SizeF size = signature.GetFeature(Size);
            int dpi = signature.GetFeature(Dpi);


            // Normalized controll point pressure values
            List<double> normalizedPressures = Normalize(ps, ps.Min<double>(), ps.Max<double>() - ps.Min<double>());

            // Signature controll points (X-Y pairs) translated to image points
            List<PointF> controllPoints = CreateImageControllPoints(dpi, xs, ys);

            // Calculating the velocities in each controll point
            List<Vector2> velocityVectors = CalculateVelocities(controllPoints, ts);
            // Extracting the length of the velocity vectors
            List<double> velocityValues = new List<double>();
            foreach (Vector2 v in velocityVectors)
            {
                velocityValues.Add(v.Length());
            }

            // Normalized velocity values (only the length of the vectors)
            List<double> normalizedVelocities = Normalize(velocityValues, velocityValues.Min(), velocityValues.Max() - velocityValues.Min());

            // Image points of the signature calculated from the controll points using a curve fitting method.
            List<Point> points = CalculateImagePoints(controllPoints, pendowns);

            // Fill missing pressure values between controll points
            List<double> pressures = LinearFill(normalizedPressures, pendowns);

            // Fill missing velocity values between controll points
            List<double> velocities = LinearFill(normalizedVelocities, pendowns);

            // Output image
            Image<Rgba32> img = CreateImage(dpi, size);

            // Set background color to white
            img.Mutate(ctx => ctx.Fill(Rgba32.White));

            // Draw the signature
            DrawSignature(img, points, pressures, velocities);

            // Add noise to the signature image
            AddNoiseToImage(img);

            // Set the output image as a feature of the signature
            signature.SetFeature(OutputImage, img);
        }

        /// <summary>
        /// Creating the output image based on the size of the signature and DPI of the device it was recorded on.
        /// </summary>
        /// <param name="dpi"> The DPI of the device the signature was recorded on. </param>
        /// <param name="size"> The size of the signature. </param>
        /// <returns> The output image object. </returns>
        private Image<Rgba32> CreateImage(int dpi, SizeF size)
        {
            double scale = outputImageDpi / dpi;
            return new Image<Rgba32>((int)Math.Ceiling(size.Width * scale) + 2 * frame, (int)Math.Ceiling(size.Height * scale) + 2 * frame);
        }

        /// <summary>
        /// Utility function for feature scaling a list of double values to the [0,1] range.
        /// </summary>
        /// <param name="values"> The list of values to be normalized. </param>
        /// <param name="minimum"> The minmum of the values to be normalized. </param>
        /// <param name="range"> The range of the values to be normalized (max - min). </param>
        /// <returns> The normalized list of values. </returns>
        private List<double> Normalize(List<double> values, double minimum, double range)
        {
            List<double> NormalizedValues = new List<double>();
            for (int i = 0; i < values.Count(); i++)
            {
                if (range <= 0)
                {
                    NormalizedValues.Add(0);
                }
                else
                {
                    NormalizedValues.Add(((values[i] - minimum) / range));
                }
            }
            return NormalizedValues;
        }

        /// <summary>
        /// Generate controll points as image points based on the coordinates of the signature.
        /// </summary>
        /// <param name="dpi"> The DPI of the device the signature was recorded on. </param>
        /// <param name="xs"> List containing the X coordinates of the signature. </param>
        /// <param name="ys"> List containing the Y coordinates of the signature. </param>
        /// <returns> A list of controll points. </returns>
        private List<PointF> CreateImageControllPoints(double dpi, List<double> xs, List<double> ys)
        {
            List<PointF> controllPoints = new List<PointF>();
            double scale = outputImageDpi / dpi;

            for (int i = 0; i < xs.Count(); i++)
            {
                controllPoints.Add(new PointF(
                    (float)((xs[i] - xs.Min() + frame) * scale),
                    (float)((ys.Max() - ys[i] + frame) * scale)
                ));
            }
            return controllPoints;
        }

        /// <summary>
        /// A function that is used for spline interpolation, using the Catmull-Rom method.
        /// </summary>
        /// <param name="controllPoints"> The controll points of the spline. </param>
        /// <param name="i"> The index of the current controll point. </param>
        /// <param name="_t"> The current time on the curve between the actual and the next controll point. </param>
        /// <returns></returns>
        private Point CatmullRomSpline(List<PointF> controllPoints, int i, double _t)
        {
            double[] t = new double[4];
            double[] x = new double[4];
            double[] y = new double[4];

            if (i == 0)
            {
                x[0] = controllPoints[0].X + (controllPoints[0].X - controllPoints[1].X) / 4;
                y[0] = controllPoints[0].Y + (controllPoints[0].Y - controllPoints[1].Y) / 4;
                for (int k = 1; k < 4; k++)
                {
                    x[k] = controllPoints[i + k - 1].X;
                    y[k] = controllPoints[i + k - 1].Y;
                }
            }
            else if (i == controllPoints.Count() - 2)
            {
                x[3] = controllPoints[controllPoints.Count() - 1].X + (controllPoints[controllPoints.Count() - 1].X - controllPoints[controllPoints.Count() - 2].X) / 4;
                y[3] = controllPoints[controllPoints.Count() - 1].Y + (controllPoints[controllPoints.Count() - 1].Y - controllPoints[controllPoints.Count() - 2].Y) / 4;
                for (int k = 1; k < 3; k++)
                {
                    x[k] = controllPoints[i + k - 1].X;
                    y[k] = controllPoints[i + k - 1].Y;
                }
            }
            else
            {
                for (int k = 0; k < 4; k++)
                {
                    x[k] = controllPoints[i + k - 1].X;
                    y[k] = controllPoints[i + k - 1].Y;
                }
            }

            t[0] = 0;
            for (int k = 0; k < 3; k++)
            {
                t[k + 1] = Math.Pow(Math.Pow(x[k + 1] - x[k], 2) + Math.Pow(y[k + 1] - y[k], 2), catmullRomAlpha / 2) + t[k];
            }

            double t_j = t[1] + (t[2] - t[1]) * _t;
            double a1_x = (t[1] - t_j) / (t[1] - t[0]) * x[0] + (t_j - t[0]) / (t[1] - t[0]) * x[1];
            double a1_y = (t[1] - t_j) / (t[1] - t[0]) * y[0] + (t_j - t[0]) / (t[1] - t[0]) * y[1];
            double a2_x = (t[2] - t_j) / (t[2] - t[1]) * x[1] + (t_j - t[1]) / (t[2] - t[1]) * x[2];
            double a2_y = (t[2] - t_j) / (t[2] - t[1]) * y[1] + (t_j - t[1]) / (t[2] - t[1]) * y[2];
            double a3_x = (t[3] - t_j) / (t[3] - t[2]) * x[2] + (t_j - t[2]) / (t[3] - t[2]) * x[3];
            double a3_y = (t[3] - t_j) / (t[3] - t[2]) * y[2] + (t_j - t[2]) / (t[3] - t[2]) * y[3];

            double b1_x = (t[2] - t_j) / (t[2] - t[0]) * a1_x + (t_j - t[0]) / (t[2] - t[0]) * a2_x;
            double b1_y = (t[2] - t_j) / (t[2] - t[0]) * a1_y + (t_j - t[0]) / (t[2] - t[0]) * a2_y;
            double b2_x = (t[3] - t_j) / (t[3] - t[1]) * a2_x + (t_j - t[1]) / (t[3] - t[1]) * a3_x;
            double b2_y = (t[3] - t_j) / (t[3] - t[1]) * a2_y + (t_j - t[1]) / (t[3] - t[1]) * a3_y;

            double p_x = (t[2] - t_j) / (t[2] - t[1]) * b1_x + (t_j - t[1]) / (t[2] - t[1]) * b2_x;
            double p_y = (t[2] - t_j) / (t[2] - t[1]) * b1_y + (t_j - t[1]) / (t[2] - t[1]) * b2_y;

            return new Point((int)p_x, (int)p_y);
        }

        /// <summary>
        /// Calculating the image points of a circle with a given radius and a center.
        /// </summary>
        /// <param name="center"> The center of the circle. </param>
        /// <param name="radius"> The radius of the circle. </param>
        /// <returns> The image points of the circle. </returns>
        private List<List<Point>> GetCirclePoints(Point center, double radius)
        {
            List<List<Point>> circlePoints = new List<List<Point>>();
            for (int y = center.Y - (int)radius; y <= center.Y + (int)radius; y++)
            {
                int start = -(int)-(center.X - Math.Sqrt(Math.Pow(radius, 2) - Math.Pow(center.Y - y, 2)));
                int end = (int)(center.X + Math.Sqrt(Math.Pow(radius, 2) - Math.Pow(center.Y - y, 2)));
                List<Point> pair = new List<Point>();
                pair.Add(new Point(start, y));
                pair.Add(new Point(end, y));
                circlePoints.Add(pair);
            }
            return circlePoints;
        }

        /// <summary>
        /// Draw a circle to an image with a given color.
        /// The circle is defined with a center and a radius.
        /// </summary>
        /// <param name="img"> The image where the circle should be drawn to. </param>
        /// <param name="center"> The center of the circle. </param>
        /// <param name="radius"> The radius of the circle. </param>
        /// <param name="color"> The color which the circle should be drawn with. </param>
        private void DrawCircle(Image<Rgba32> img, Point center, double radius, Rgba32 color)
        {
            List<List<Point>> circlePoints = GetCirclePoints(center, radius);
            for (int i = 0; i < circlePoints.Count; i++)
                if (circlePoints[i][0].Y >= 0 && circlePoints[i][0].Y < img.Height)
                    for (int j = circlePoints[i][0].X; j <= circlePoints[i][1].X; j++)
                        if (j >= 0 && j < img.Width)
                        {
                            Rgba32 baseColor = img[j, circlePoints[i][0].Y];
                            Rgba32 newColor = new Rgba32(
                                baseColor.R < color.R ? baseColor.R : color.R,
                                baseColor.G < color.G ? baseColor.G : color.G,
                                baseColor.B < color.B ? baseColor.B : color.B,
                                255
                            );
                            img[j, circlePoints[i][0].Y] = newColor;
                        }
        }

        /// <summary>
        /// Calculate the velocity vectors between a list of points.
        /// </summary>
        /// <param name="points"> A list of points. </param>
        /// <param name="ts"> A list of time values. </param>
        /// <returns> A list of velocity vectors. </returns>
        private List<Vector2> CalculateVelocities(List<PointF> points, List<double> ts)
        {
            Vector2[] velocities = new Vector2[points.Count()];
            velocities[0] = new Vector2(0.0f, 0.0f);
            velocities[points.Count() - 1] = new Vector2(0.0f, 0.0f);
            for (int i = 1; i < points.Count() - 1; i++)
            {
                double timeDelta0 = ts[i] <= ts[i - 1] ? 10 : ts[i] - ts[i - 1];
                double timeDelta1 = ts[i + 1] <= ts[i] ? 10 : ts[i + 1] - ts[i];
                Vector2 speed1 = new Vector2(points[i].X - points[i - 1].X, points[i].Y - points[i - 1].Y) / (float)timeDelta0;
                Vector2 speed2 = new Vector2(points[i + 1].X - points[i].X, points[i + 1].Y - points[i].Y) / (float)timeDelta1;
                velocities[i] = (speed1 + speed2) / 2;
            }

            // Converting the returned object to a List
            List<Vector2> returnList = new List<Vector2>();
            returnList.AddRange(velocities);
            return returnList;
        }

        /// <summary>
        /// Generate the image points of the signature based on the controll points and the pendown feature.
        /// </summary>
        /// <param name="controllPoints"> A list of controll points. </param>
        /// <param name="pendowns"> <see cref="Features.PenDown"/> A list of pendown values. </param>
        /// <returns> List of image points building up the signature. </returns>
        private List<Point> CalculateImagePoints(List<PointF> controllPoints, List<bool> pendowns)
        {
            List<Point> points = new List<Point>();
            for (int i = 0; i < controllPoints.Count() - 1; i++)
            {
                if (!pendowns[i + 1])
                {
                    continue;
                }

                for (double t = 0.0; t <= 1.0; t += catmullRomStep)
                {
                    points.Add(CatmullRomSpline(controllPoints, i, t));
                }
            }
            return points;
        }


        /// <summary>
        /// Fill missing values between controll points with a linear interpolation.
        /// </summary>
        /// <param name="values"> List of values that needs to be propagated. </param>
        /// <param name="pendowns"> <see cref="Features.PenDown"/> A list of pendown values. </param>
        /// <returns> A list containing the propagated values and the original values in order. </returns>
        private List<double> LinearFill(List<double> values, List<bool> pendowns)
        {
            int pointsPerSpline = (int)(1 / catmullRomStep);
            List<double> propagatedValues = new List<double>();
            for (int i = 0; i < values.Count() - 1; i++)
            {
                if (!pendowns[i + 1])
                {
                    continue;
                }

                propagatedValues.Add(values[i]);
                for (int j = 0; j < pointsPerSpline; j++)
                {
                    propagatedValues.Add((values[i] * (pointsPerSpline - j) + values[i + 1] * j) / pointsPerSpline);
                }
            }
            return propagatedValues;
        }

        /// <summary>
        /// Draw the signature to the image.
        /// </summary>
        /// <param name="img"> The image where the signature should be drawn to.  </param>
        /// <param name="points"> The points of the signature (both the controll points and the interpolated ones in order). </param>
        /// <param name="pressures"> The pressure values of the signature points (both the controll points and the propagated ones in order). </param>
        /// <param name="velocities"> The velocity values of the signature points (both the controll points and the propagated ones in order). </param>
        private void DrawSignature(Image<Rgba32> img, List<Point> points, List<double> pressures, List<double> velocities)
        {
            double baseRadius = 5;
            double averageVelocity = velocities.Average();
            double averagePressure = pressures.Average();

            img.Mutate(ctx =>
            {
                for (int i = 0; i < numberOfLayers; i++)
                {
                    for (int j = 0; j < points.Count() - 1; j++)
                    {
                        // Scale intensity with the layer's value and the velocity
                        double intensity = baseIntensity * layers[i].intensity;
                        intensity *= averageVelocity / (velocities[j] > 0 ? velocities[j] : 0.1);
                        intensity = Math.Min(intensity, 1);

                        // Scale the width of the line with the layer's value and the pressure
                        double radius = baseRadius * layers[i].width;
                        radius *= (pressures[j] > 0 ? pressures[j] : 0.1) / averagePressure;

                        // Draw a circle to the given point with the color determined by the intensity and the radius calculated above
                        Rgba32 color = new Rgba32((byte)(255 - intensity * 155.0), (byte)(255 - intensity * 165.0), (byte)(255 - intensity * 75.0), (byte)255);
                        DrawCircle(img, points[j], radius, color);
                    }
                }
            });
        }

        /// <summary>
        /// Add pseudo random noise to an image. The final noise is based on combining different noise layers.
        /// <see cref="numberOfNoiseLayers"/>
        /// </summary>
        /// <param name="img"> The image to which the noise should be added to. </param>
        private void AddNoiseToImage(Image<Rgba32> img)
        {
            // Calculate the noise by creating and combining noise layers
            double[,] noise = CalculateNoise(img);

            // Add the generated noise to the image
            for (int i = 0; i < img.Height; i++)
            {
                for (int j = 0; j < img.Width; j++)
                {
                    Rgba32 pixel = img[j, i];
                    int redOffset = 255 - pixel.R;
                    int greenOffset = 255 - pixel.G;
                    int blueOffset = 255 - pixel.B;
                    redOffset = (int)(redOffset * noise[j, i]);
                    greenOffset = (int)(greenOffset * noise[j, i]);
                    blueOffset = (int)(blueOffset * noise[j, i]);
                    redOffset = Math.Min(redOffset, 255);
                    greenOffset = Math.Min(greenOffset, 255);
                    blueOffset = Math.Min(blueOffset, 255);
                    img[j, i] = new Rgba32((byte)(255 - redOffset), (byte)(255 - greenOffset), (byte)(255 - blueOffset), (byte)(255));
                }
            }
        }

        /// <summary>
        /// Calculate the noise that will be added to the immage as a two dimensional double array.
        /// </summary>
        /// <param name="img"> The image which the noise should be added to. </param>
        /// <returns> The noise as a two dimensional double arrray </returns>
        private double[,] CalculateNoise(Image<Rgba32> img)
        {
            // Initialize random object
            Random rng = new Random(42);

            // Create the first layer
            double[,] noiseLayer1;
            if (numberOfNoiseLayers <= 1)
            {
                noiseLayer1 = new double[
                  img.Width,
                  img.Height
                ];
            }
            else
            {
                noiseLayer1 = new double[
                  (int)(img.Width / Math.Pow(noiseLayerScale, numberOfNoiseLayers - 1)),
                  (int)(img.Height / Math.Pow(noiseLayerScale, numberOfNoiseLayers - 1))
                ];
            }


            for (int i = 0; i < noiseLayer1.GetLength(0); i++)
            {
                for (int j = 0; j < noiseLayer1.GetLength(1); j++)
                {
                    noiseLayer1[i, j] = rng.NextDouble()  * noiseRandomValueUpperBound;
                }
            }

            if (numberOfNoiseLayers <= 1)
            {
                return noiseLayer1;
            }

            // Calculate the noise by combining noise layers together
            double[,] prveiousNoiseLayer = noiseLayer1;
            double[,] noiseLayer = noiseLayer1;
            for (int i = 1; i < numberOfNoiseLayers; i++)
            {
                noiseLayer = CreateNoiseLayer(img, numberOfNoiseLayers - i - 1, prveiousNoiseLayer, rng);
                prveiousNoiseLayer = noiseLayer;

            }
            return noiseLayer;
        }

        /// <summary>
        /// Method that creates a noise layer based on the previous layer.
        /// </summary>
        /// <param name="img"> The image which the noise should be added to. </param>
        /// <param name="exponent"> Exponent used in scaling the layer. </param>
        /// <param name="previousNoiseLayer"> The previous noise layer. </param>
        /// <param name="rng"> A random object. </param>
        /// <returns> A noise layer as a two dimensinal double array. </returns>
        private double[,] CreateNoiseLayer(Image<Rgba32> img, int exponent, double[,] previousNoiseLayer, Random rng)
        {
            double[,] noiseLayer = new double[
                (int)(img.Width / Math.Pow(noiseLayerScale, exponent)),
                (int)(img.Height / Math.Pow(noiseLayerScale, exponent))
            ];
            for (int i = 0; i < noiseLayer.GetLength(0); i++)
            {
                double base_x = ((double)i) / noiseLayer.GetLength(0) * previousNoiseLayer.GetLength(0);
                int base_x_0 = (int)base_x;
                int base_x_1 = (int)base_x + 2 < previousNoiseLayer.GetLength(0) ? (int)base_x + 1 : (int)base_x;
                double ratio_x = 1 - (base_x - base_x_0);
                for (int j = 0; j < noiseLayer.GetLength(1); j++)
                {
                    double base_y = ((double)j) / noiseLayer.GetLength(1) * previousNoiseLayer.GetLength(1);
                    int base_y_0 = (int)base_y;
                    int base_y_1 = (int)base_y + 2 < previousNoiseLayer.GetLength(1) ? (int)base_y + 1 : (int)base_y;
                    double ratio_y = 1 - (base_y - base_y_0);
                    noiseLayer[i, j] =
                        previousNoiseLayer[base_x_0, base_y_0] * ratio_x * ratio_y +
                        previousNoiseLayer[base_x_0, base_y_1] * ratio_x * (1 - ratio_y) +
                        previousNoiseLayer[base_x_1, base_y_0] * (1 - ratio_x) * ratio_y +
                        previousNoiseLayer[base_x_1, base_y_1] * (1 - ratio_x) * (1 - ratio_y) +
                        rng.NextDouble() * noiseRandomValueUpperBound;
                }
            }
            return noiseLayer;
        }

    }
}