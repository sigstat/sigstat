using System.Collections.Generic;
using SigStat.Common.Pipeline;
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.PixelFormats;
using SixLabors.ImageSharp.Processing;
using SixLabors.Primitives;
using System.Linq;
using System;
using System.Numerics;

namespace SigStat.Common.PipelineItems.Transforms.Raster
{
    /// <summary>
    /// Generates a realistic looking image of the Signature based on standard features. Uses blue ink and white paper. It does NOT save the image to file.
    /// <para>Default Pipeline Input: X, Y, T, Pressure, Size, PenDown, Dpi <see cref="Features"/></para>
    /// <para>Default Pipeline Output: OutputImage <see cref="Features.Image"/></para>
    /// </summary>
    public class RealisticImageGenerator2 : PipelineBase, ITransformation
    {
        /// <summary>
        /// Input <see cref="FeatureDescriptor"/> describing the X coordinates of an online signature
        /// </summary>
        [Input]
        public FeatureDescriptor<List<double>> X { get; set; } = Features.X;

        /// <summary>
        /// Input <see cref="FeatureDescriptor"/> describing the Y coordinates of an online signature
        /// </summary>
        [Input]
        public FeatureDescriptor<List<double>> Y { get; set; } = Features.Y;

        /// <summary>
        /// Input <see cref="FeatureDescriptor"/> describing the time values of an online signature
        /// </summary>
        [Input]
        public FeatureDescriptor<List<double>> T { get; set; } = Features.T;

        /// <summary>
        /// Input <see cref="FeatureDescriptor"/> describing the pressure values of an online signature
        /// </summary>
        [Input]
        public FeatureDescriptor<List<double>> Pressure { get; set; } = Features.Pressure;

        /// <summary>
        /// Input <see cref="FeatureDescriptor"/> describing the pressure values of an online signature
        /// </summary>
        [Input]
        public FeatureDescriptor<SizeF> Size { get; set; } = Features.Size;

        /// <summary>
        /// Input <see cref="FeatureDescriptor"/> describing the stroke endings of an online signature
        /// </summary>
        [Input]
        public FeatureDescriptor<List<bool>> PenDown { get; set; } = Features.PenDown;

        /// <summary>
        /// Input <see cref="FeatureDescriptor"/> describing the dots per inch paramater of the device where the  online signature was recorded
        /// </summary>
        public FeatureDescriptor<int> Dpi { get; set; } = Features.Dpi;

        /// <summary>
        /// Output <see cref="FeatureDescriptor"/> describing the generated image of the signature
        /// </summary>
        [Output("RealisticImage")]
        public FeatureDescriptor<Image<Rgba32>> OutputImage { get; set; } = Features.Image;

        // The width of the frame around the generated signature image
        private readonly int frame;
        // Alpha paramater of the Catmull-Rom spline based interpolation
        private readonly double catmullRomAlpha;
        // The DPI of the target device
        private readonly double outputImageDpi;
        // Distance between points generated by the Catmull-Rom spline based interpolation
        // This value determines the number of points between each controll points
        private readonly double catmullRomStep;
        // Base color intensity value for the image generation
        private readonly double baseIntensity;

        public RealisticImageGenerator2(int frame, double catmullRomAlpha, double outputImageDpi, double catmullRomStep = 0.01, double baseIntensity = 1)
        {
            this.frame = frame;
            this.catmullRomAlpha = catmullRomAlpha;
            this.outputImageDpi = outputImageDpi;
            this.catmullRomStep = catmullRomStep;
            this.baseIntensity = baseIntensity;
        }

        public void Transform(Signature signature)
        {
            List<double> xs = signature.GetFeature(X);
            List<double> ys = signature.GetFeature(Y);
            List<double> ts = signature.GetFeature(T);
            List<double> ps = signature.GetFeature(Pressure);
            List<bool> pendowns = signature.GetFeature(PenDown);
            SizeF size = signature.GetFeature(Size);
            int dpi = signature.GetFeature(Dpi);


            // Normalized controll point pressure values
            List<double> normalizedPressures = Normalize(ps, ps.Min<double>(), ps.Max<double>() - ps.Min<double>());

            // Signature controll points (X-Y pairs) translated to image points
            List<PointF> controllPoints = CreateImageControllPoints(dpi, xs, ys);

            // Calculating the velocities in each controll point
            List<Vector2> velocityVectors = CalculateVelocities(controllPoints, ts);
            // Extracting the length of the velocity vectors
            List<double> velocityValues = new List<double>();
            foreach (Vector2 v in velocityVectors)
            {
                velocityValues.Add(v.Length());
            }

            // Normalized velocity values (only the length of the vectors)
            List<double> normalizedVelocities = Normalize(velocityValues, velocityValues.Min(), velocityValues.Max() - velocityValues.Min());

            // Image points of the signature calculated from the controll points using a curve fitting method.
            List<Point> points = CalculateImagePoints(controllPoints, pendowns);

            // Fill missing pressure values between controll points
            List<double> pressures = LinearFill(normalizedPressures, pendowns);

            // Fill missing velocity values between controll points
            List<double> velocities = LinearFill(normalizedVelocities, pendowns);

            // Output image
            Image<Rgba32> img = CreateImage(dpi, size);

            // Set background color to white
            img.Mutate(ctx => ctx.Fill(Rgba32.White));

            // Draw the signature
            DrawSignature(img, points, pressures, velocities);

            // Set the output image as a feature of the signature
            signature.SetFeature(OutputImage, img);
        }

        /// <summary>
        /// Creating the output image based on the size of the signature and DPI of the device it was recorded on.
        /// </summary>
        /// <param name="dpi"> The DPI of the device the signature was recorded on. </param>
        /// <param name="size"> The size of the signature. </param>
        /// <returns> The output image object. </returns>
        private Image<Rgba32> CreateImage(int dpi, SizeF size)
        {
            double scale = outputImageDpi / dpi;
            return new Image<Rgba32>((int)Math.Ceiling(size.Width * scale) + 2 * frame, (int)Math.Ceiling(size.Height * scale) + 2 * frame);
        }

        /// <summary>
        /// Utility function for feature scaling a list of double values to the [0,1] range.
        /// </summary>
        /// <param name="values"> The list of values to be normalized. </param>
        /// <param name="minimum"> The minmum of the values to be normalized. </param>
        /// <param name="range"> The range of the values to be normalized (max - min). </param>
        /// <returns> The normalized list of values. </returns>
        private List<double> Normalize(List<double> values, double minimum, double range)
        {
            List<double> NormalizedValues = new List<double>();
            for (int i = 0; i < values.Count(); i++)
            {
                if (range == 0)
                {
                    NormalizedValues.Add(0);
                }
                else
                {
                    NormalizedValues.Add(((values[i] - minimum) / range));
                }
            }
            return NormalizedValues;
        }

        /// <summary>
        /// Generate controll points as image points based on the coordinates of the signature.
        /// </summary>
        /// <param name="dpi"> The DPI of the device the signature was recorded on. </param>
        /// <param name="xs"> List containing the X coordinates of the signature. </param>
        /// <param name="ys"> List containing the Y coordinates of the signature. </param>
        /// <returns> A list of controll points. </returns>
        private List<PointF> CreateImageControllPoints(double dpi, List<double> xs, List<double> ys)
        {
            List<PointF> controllPoints = new List<PointF>();
            double scale = outputImageDpi / dpi;

            for (int i = 0; i < xs.Count(); i++)
            {
                controllPoints.Add(new PointF(
                    (float)((xs[i]  - xs.Min() + frame) * scale),
                    (float)((ys.Max() - ys[i] + frame) * scale)
                ));
            }
            return controllPoints;
        }

        /// <summary>
        /// A function that is used for spline interpolation, using the Catmull-Rom method.
        /// </summary>
        /// <param name="controllPoints"> The controll points of the spline. </param>
        /// <param name="i"> The index of the current controll point. </param>
        /// <param name="_t"> The current time on the curve between the actual and the next controll point. </param>
        /// <returns></returns>
        private Point CatmullRomSpline(List<PointF> controllPoints, int i, double _t)
        {
            double[] t = new double[4];
            double[] x = new double[4];
            double[] y = new double[4];

            if (i == 0)
            {
                x[0] = controllPoints[0].X + (controllPoints[0].X - controllPoints[1].X) / 4;
                y[0] = controllPoints[0].Y + (controllPoints[0].Y - controllPoints[1].Y) / 4;
                for (int k = 1; k < 4; k++)
                {
                    x[k] = controllPoints[i + k - 1].X;
                    y[k] = controllPoints[i + k - 1].Y;
                }
            }
            else if (i == controllPoints.Count() - 2)
            {
                x[3] = controllPoints[controllPoints.Count() - 1].X + (controllPoints[controllPoints.Count() - 1].X - controllPoints[controllPoints.Count() - 2].X) / 4;
                y[3] = controllPoints[controllPoints.Count() - 1].Y + (controllPoints[controllPoints.Count() - 1].Y - controllPoints[controllPoints.Count() - 2].Y) / 4;
                for (int k = 1; k < 3; k++)
                {
                    x[k] = controllPoints[i + k - 1].X;
                    y[k] = controllPoints[i + k - 1].Y;
                }
            }
            else
            {
                for (int k = 0; k < 4; k++)
                {
                    x[k] = controllPoints[i + k - 1].X;
                    y[k] = controllPoints[i + k - 1].Y;
                }
            }

            t[0] = 0;
            for (int k = 0; k < 3; k++)
            {
                t[k + 1] = Math.Pow(Math.Pow(x[k + 1] - x[k], 2) + Math.Pow(y[k + 1] - y[k], 2), catmullRomAlpha / 2) + t[k];
            }

            double t_j = t[1] + (t[2] - t[1]) * _t;
            double a1_x = (t[1] - t_j) / (t[1] - t[0]) * x[0] + (t_j - t[0]) / (t[1] - t[0]) * x[1];
            double a1_y = (t[1] - t_j) / (t[1] - t[0]) * y[0] + (t_j - t[0]) / (t[1] - t[0]) * y[1];
            double a2_x = (t[2] - t_j) / (t[2] - t[1]) * x[1] + (t_j - t[1]) / (t[2] - t[1]) * x[2];
            double a2_y = (t[2] - t_j) / (t[2] - t[1]) * y[1] + (t_j - t[1]) / (t[2] - t[1]) * y[2];
            double a3_x = (t[3] - t_j) / (t[3] - t[2]) * x[2] + (t_j - t[2]) / (t[3] - t[2]) * x[3];
            double a3_y = (t[3] - t_j) / (t[3] - t[2]) * y[2] + (t_j - t[2]) / (t[3] - t[2]) * y[3];

            double b1_x = (t[2] - t_j) / (t[2] - t[0]) * a1_x + (t_j - t[0]) / (t[2] - t[0]) * a2_x;
            double b1_y = (t[2] - t_j) / (t[2] - t[0]) * a1_y + (t_j - t[0]) / (t[2] - t[0]) * a2_y;
            double b2_x = (t[3] - t_j) / (t[3] - t[1]) * a2_x + (t_j - t[1]) / (t[3] - t[1]) * a3_x;
            double b2_y = (t[3] - t_j) / (t[3] - t[1]) * a2_y + (t_j - t[1]) / (t[3] - t[1]) * a3_y;

            double p_x = (t[2] - t_j) / (t[2] - t[1]) * b1_x + (t_j - t[1]) / (t[2] - t[1]) * b2_x;
            double p_y = (t[2] - t_j) / (t[2] - t[1]) * b1_y + (t_j - t[1]) / (t[2] - t[1]) * b2_y;

            return new Point((int)p_x, (int)p_y);
        }

        /// <summary>
        /// Calculating the image points of a circle with a given radius and a center.
        /// </summary>
        /// <param name="center"> The center of the circle. </param>
        /// <param name="radius"> The radius of the circle. </param>
        /// <returns> The image points of the circle. </returns>
        private List<List<Point>> GetCirclePoints(Point center, double radius)
        {
            List<List<Point>> circlePoints = new List<List<Point>>();
            for (int y = center.Y - (int)radius; y <= center.Y + (int)radius; y++)
            {
                int start = -(int)-(center.X - Math.Sqrt(Math.Pow(radius, 2) - Math.Pow(center.Y - y, 2)));
                int end = (int)(center.X + Math.Sqrt(Math.Pow(radius, 2) - Math.Pow(center.Y - y, 2)));
                List<Point> pair = new List<Point>();
                pair.Add(new Point(start, y));
                pair.Add(new Point(end, y));
                circlePoints.Add(pair);
            }
            return circlePoints;
        }

        /// <summary>
        /// Draw a circle to an image with a given color.
        /// The circle is defined with a center and a radius.
        /// </summary>
        /// <param name="img"> The image where the circle should be drawn to. </param>
        /// <param name="center"> The center of the circle. </param>
        /// <param name="radius"> The radius of the circle. </param>
        /// <param name="color"> The color which the circle should be drawn with. </param>
        private void DrawCircle(Image<Rgba32> img, Point center, double radius, Rgba32 color)
        {
            List<List<Point>> circlePoints = GetCirclePoints(center, radius);
            for (int i = 0; i < circlePoints.Count; i++)
                if (circlePoints[i][0].Y >= 0 & circlePoints[i][0].Y < img.Height)
                    for (int j = circlePoints[i][0].X; j <= circlePoints[i][1].X; j++)
                        if (j >= 0 & j < img.Width)
                        {
                            img[j, circlePoints[i][0].Y] = color;
                        }
        }

        /// <summary>
        /// Calculate the velocity vectors between a list of points.
        /// </summary>
        /// <param name="points"> A list of points. </param>
        /// <param name="ts"> A list of time values. </param>
        /// <returns> A list of velocity vectors. </returns>
        private List<Vector2> CalculateVelocities(List<PointF> points, List<double> ts)
        {
            Vector2[] velocities = new Vector2[points.Count()];
            velocities[0] = new Vector2(0.0f, 0.0f);
            velocities[points.Count() - 1] = new Vector2(0.0f, 0.0f);
            for (int i = 1; i < points.Count() - 1; i++)
            {
                double timeDelta0 = ts[i] == ts[i - 1] ? 10 : ts[i] - ts[i - 1];
                double timeDelta1 = ts[i + 1] == ts[i] ? 10 : ts[i + 1] - ts[i];
                Vector2 speed1 = new Vector2(points[i].X - points[i - 1].X, points[i].Y - points[i - 1].Y) / (float) timeDelta0;
                Vector2 speed2 = new Vector2(points[i + 1].X - points[i].X, points[i + 1].Y - points[i].Y) / (float) timeDelta1;
                velocities[i] = (speed1 + speed2) / 2;
            }

            // Converting the returned object to a List
            List<Vector2> returnList = new List<Vector2>();
            returnList.AddRange(velocities);
            return returnList;
        }

        /// <summary>
        /// Generate the image points of the signature based on the controll points and the pendown feature.
        /// </summary>
        /// <param name="controllPoints"> A list of controll points. </param>
        /// <param name="pendowns"> <see cref="Features.PenDown"/> A list of pendown values. </param>
        /// <returns> List of image points building up the signature. </returns>
        private List<Point> CalculateImagePoints(List<PointF> controllPoints, List<bool> pendowns)
        {
            List<Point> points = new List<Point>();
            for (int i = 0; i < controllPoints.Count() - 1; i++)
            {
                if (!pendowns[i + 1])
                {
                    continue;
                }

                for (double t = 0.0; t <= 1.0; t += catmullRomStep)
                {
                    points.Add(CatmullRomSpline(controllPoints, i, t));
                }
            }
            return points;
        }


        /// <summary>
        /// Fill missing values between controll points with a linear interpolation.
        /// </summary>
        /// <param name="values"> List of values that needs to be propagated. </param>
        /// <param name="pendowns"> <see cref="Features.PenDown"/> A list of pendown values. </param>
        /// <returns> A list containing the propagated values and the original values in order. </returns>
        private List<double> LinearFill(List<double> values, List<bool> pendowns)
        {
            int pointsPerSpline = (int) (1 / catmullRomStep);
            List<double> propagatedValues = new List<double>();
            for(int i = 0; i < values.Count() - 1; i++)
            {
                if(!pendowns[i + 1])
                {
                    continue;
                }

                propagatedValues.Add(values[i]);
                for(int j = 0; j < pointsPerSpline; j++)
                {
                    propagatedValues.Add((values[i] * (pointsPerSpline - j) + values[i + 1] * j) / pointsPerSpline);
                }
            }
            return propagatedValues;
        }

        /// <summary>
        /// Draw the signature to the image.
        /// </summary>
        /// <param name="img"> The image where the signature should be drawn to.  </param>
        /// <param name="points"> The points of the signature (both the controll points and the interpolated ones in order). </param>
        /// <param name="pressures"> The pressure values of the signature points (both the controll points and the propagated ones in order). </param>
        /// <param name="velocities"> The velocity values of the signature points (both the controll points and the propagated ones in order). </param>
        private void DrawSignature(Image<Rgba32> img, List<Point> points, List<double> pressures, List<double> velocities)
        {
            double baseRadius = 5;
            img.Mutate(ctx =>
            {
                for (int i = 0; i < points.Count() - 1; i++)
                {

                    double intensity = baseIntensity;
                    intensity *=  pressures[i];
                    intensity = Math.Min(intensity, 1);
                    double radius = baseRadius;
                    radius = velocities[i] >= 1 ? radius * 0.1 : radius * (1 - velocities[i]);
                    Rgba32 color = new Rgba32((byte)(255 - intensity * 155.0), (byte)(255 - intensity * 165.0), (byte)(255 - intensity * 75.0), (byte)255);
                    DrawCircle(img, points[i], radius, color);
                }
            });
        }

    }
}
